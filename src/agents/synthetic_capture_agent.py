import pathlib, cv2, numpy as np, queue, threading, time
from .base_agent import BaseAgent

# Import our logger bridge
try:
    import logger_bridge as log

# Import global function tracer
try:
    from tracer.client import safe_trace_calls as trace_calls
    TRACER_AVAILABLE = True
except ImportError:
    TRACER_AVAILABLE = False

    LOGGER_AVAILABLE = True
except ImportError:
    LOGGER_AVAILABLE = False



class SyntheticCaptureAgent(BaseAgent):
    """
    Emits a single static frame (the dummy board image) repeatedly.
    No screen access – fully portable.
    """

    def __init__(self, fps: int = 60):
    @trace_calls('__init__', 'synthetic_capture_agent.py', 27)
        self.fps = fps
        self.frame_queue = queue.Queue(maxsize=10)
        self._stop = threading.Event()
        self._thread = None

        # Load the dummy board image generated by create_dummy_board.py
        img_path = (
            pathlib.Path(__file__).parent.parent.parent / "tools" / "board_sample.png"
        )
        if not img_path.is_file():
            raise FileNotFoundError(f"Dummy board image not found: {img_path}")
        self._frame = cv2.imread(str(img_path))

        # Resize to a realistic size (optional)
        self._frame = cv2.resize(self._frame, (640, 1280))  # width×height

    def _run(self):
    @trace_calls('_run', 'synthetic_capture_agent.py', 44)
        period = 1.0 / self.fps
        while not self._stop.is_set():
            start = time.perf_counter()
            try:
                self.frame_queue.put(self._frame, timeout=0.1)
            except queue.Full:
                # drop oldest frame
                try:
                    _ = self.frame_queue.get_nowait()
                    self.frame_queue.put_nowait(self._frame)
                except queue.Empty:
                    pass
            # enforce FPS
            elapsed = time.perf_counter() - start
            if elapsed < period:
                time.sleep(period - elapsed)

    def start(self):
    @trace_calls('start', 'synthetic_capture_agent.py', 62)
        if self._thread and self._thread.is_alive():
            return
        self._stop.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
    @trace_calls('stop', 'synthetic_capture_agent.py', 69)
        self._stop.set()
        if self._thread:
            self._thread.join()

    def handle(self, params: dict | None = None) -> None:
    @trace_calls('handle', 'synthetic_capture_agent.py', 74)
        """Start/stop capture based on orchestrator request."""
        if params and params.get("stop"):
            self.stop()
        else:
            self.start()
